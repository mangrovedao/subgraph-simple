type Account @entity {
  id: Bytes!
  "Address of the account"
  address: Bytes!
  "Time that the account was first seen on Mangrove"
  creationDate: BigInt!
  "Last time that the account interacted with Mangrove"
  latestInteractionDate: BigInt!
  "Wether the account has deployed a proxy yet"
  proxyDeployed: Boolean!
  "The proxy address of the account, if deployed"
  proxy: Bytes

  "Wether the account is a referrer of some other user"
  isReferrer: Boolean!

  "The account that referred this account"
  referrer: Account
  "The accounts that this account has referred"
  referrals: [Account!]! @derivedFrom(field: "referrer")
}

type Token @entity {
  id: Bytes!
  address: Bytes!
  "The ERC20 name for the token"
  name: String!
  "The ERC20 symbol for the token"
  symbol: String!
  "The number of decimals to use when displaying the token"
  decimals: BigInt!
}

type Market @entity {
  id: String!
  "Outbound token of the market"
  outboundToken: Bytes!
  "Inbound token of the market"
  inboundToken: Bytes!
  "Spacing between ticks on the market"
  tickSpacing: BigInt!
  "If the market is able to be used"
  active: Boolean!

  gasBase: BigInt!
  "The fee charged when trading on the market"
  fee: BigInt!
}

type Offer @entity {
  id: String!
  latestTransactionHash: Bytes!
  latestLogIndex: BigInt!
  creationDate: BigInt!
  latestUpdateDate: BigInt!
  offerId: BigInt!
  "The tick of the offer, used to determine the price"
  tick: BigInt!
  "The amount of the outbound token that the offer gives"
  gives: BigInt!
  gasPrice: BigInt!
  gasReq: BigInt!
  gasBase: BigInt!
  "If the offer is open"
  isOpen: Boolean!
  "If the offer has failed"
  isFailed: Boolean!
  "If the offer has been filled completely"
  isFilled: Boolean!
  "If the offer has been retracted"
  isRetracted: Boolean!
  "The reason the offer failed, if it did"
  failedReason: Bytes
  "The reason the posthook failed, if it did"
  posthookFailReason: Bytes
  deprovisioned: Boolean!
  "The last penalty that the offer paid"
  latestPenalty: BigInt!
  "The total penalty that the offer has paid across all partial fills"
  totalPenalty: BigInt!
  "The total amount of the inbound token that the offer has got"
  totalGot: BigInt!
  "The total amount of the outbound token that the offer has given"
  totalGave: BigInt!
  "The previous amount of output token that the offer was promising"
  prevGives: BigInt
  prevTick: BigInt

  "The market that the offer is on"
  market: Market!
  "The wallet or contract that created the offer"
  maker: Account!
  "The wallet that created the offer, traced through Kandels and Limit Orders"
  realMaker: Account!
  owner: Account
  "The limit order that placed the offer, if any"
  limitOrder: LimitOrder
  "The Kandel that placed the order, if any"
  kandel: Kandel
  "The index of the offer in the Kandel offer list"
  kandelIndex: BigInt
  "The amplified offer that the offer belongs to, if any"
  amplifiedOffer: AmplifiedOffer
}

type OfferFilled @entity {
  id: String!

  "When the offer was filled"
  creationDate: BigInt
  "The transaction the offer was filled on"
  transactionHash: Bytes!

  "The account that filled the offer"
  taker: Account!
  account: Account!
  "The market that the offer was on"
  market: Market!

  "The amount of the inbound token that the maker got"
  makerGot: BigInt!
  "The amount of the outbound token that the maker gave"
  makerGave: BigInt!
  "The display value of makerGot for use in UIs"
  makerGotDisplay: BigDecimal!
  "The display value of makerGave for use in UIs"
  makerGaveDisplay: BigDecimal!

  "The offer that was filled"
  offer: Offer
}

type CleanOrder @entity {
  id: String!
  transactionHash: Bytes!
  creationDate: BigInt!

  taker: Account!
  offersToBeCleaned: BigInt!
  orders: [Order!]! @derivedFrom(field: "cleanOrder")

  market: Market
}

type Order @entity {
  id: String!
  transactionHash: Bytes!
  creationDate: BigInt!

  fillVolume: BigInt!
  fillWants: Boolean!
  maxTick: BigInt!
  taker: Account!
  takerGot: BigInt!
  takerGave: BigInt!
  penalty: BigInt!
  feePaid: BigInt!

  market: Market
  limitOrder: LimitOrder
  cleanOrder: CleanOrder
}

type AmplifiedOffer @entity {
  id: String!

  inboundRoute: Bytes
  outboundRoute: Bytes

  bundle: AmplifiedOfferBundle!
  owner: Account
  offer: Offer!
}

type AmplifiedOfferBundle @entity {
  id: String!
  creationDate: BigInt!
  bundleId: BigInt!
  expiryDate: BigInt!

  offers: [AmplifiedOffer!]!
  owner: Account
}

type LimitOrder @entity {
  id: String!
  creationDate: BigInt!
  latestUpdateDate: BigInt!
  expiryDate: BigInt
  maxVolume: BigInt
  orderType: Int!
  tick: BigInt!
  fillVolume: BigInt!
  fillWants: Boolean!

  realTaker: Account!

  inboundRoute: Bytes!
  outboundRoute: Bytes!

  offer: Offer
  order: Order

  isOpen: Boolean
}

type KandelDepositWithdraw @entity {
  id: String!
  transactionHash: Bytes!
  date: BigInt!
  token: Bytes!
  amount: BigInt!
  isDeposit: Boolean!

  kandel: Kandel!
}

type Kandel @entity {
  id: Bytes!
  transactionHash: Bytes!
  creationDate: BigInt!

  seeder: Bytes!
  address: Bytes!

  base: Bytes!
  quote: Bytes!
  baseQuoteOlKeyHash: Bytes!
  quoteBaseOlKeyHash: Bytes!
  deployer: Account!
  admin: Account!

  inboundRoute: Bytes
  outboundRoute: Bytes

  type: String!

  # Only for kandel AAVE
  reserveId: Bytes
  router: Bytes

  depositedBase: BigInt!
  depositedQuote: BigInt!

  totalPublishedBase: BigInt!
  totalPublishedQuote: BigInt!

  # Parameters
  gasPrice: BigInt
  gasReq: BigInt
  stepSize: BigInt
  baseQuoteTickOffset: BigInt
  length: BigInt

  offerIndexes: [String!]!

  offers: [Offer!]! @derivedFrom(field: "kandel")
  depositWithdraws: [KandelDepositWithdraw!]! @derivedFrom(field: "kandel")
  parameters: [KandelParameters!]! @derivedFrom(field: "kandel")
  populateRetracts: [KandelPopulateRetract!]! @derivedFrom(field: "kandel")
}

type KandelPopulateRetract @entity {
  id: String!
  transactionHash: Bytes!
  creationDate: BigInt!
  startLogIndex: BigInt!

  isRetract: Boolean!
  offerGives: [String!]!

  kandel: Kandel!
}

type KandelParameters @entity {
  id: String!
  transactionHash: Bytes!
  creationDate: BigInt!

  gasPrice: BigInt
  gasReq: BigInt
  baseQuoteTickOffset: BigInt
  stepSize: BigInt
  length: BigInt

  kandel: Kandel!
}

type Stack @entity {
  id: String!
  ids: String!
}
