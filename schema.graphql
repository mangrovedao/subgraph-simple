"A user of the Mangrove protocol, either a wallet or a contract"
type Account @entity {
  "The unique identifier for the account (same as address in this case)"
  id: Bytes!
  "Address of the account"
  address: Bytes!
  "Time that the account was first seen on Mangrove"
  creationDate: BigInt!
  "Last time that the account interacted with Mangrove"
  latestInteractionDate: BigInt!
  "If the account has deployed a proxy yet"
  proxyDeployed: Boolean!
  "The proxy address of the account, if deployed"
  proxy: Bytes

  # Referral system properties
  "If the account is a referrer of some other user"
  isReferrer: Boolean!
  "The account that referred this account"
  referrer: Account
  "The accounts that this account has referred"
  referrals: [Account!]! @derivedFrom(field: "referrer")
}

"The total amount of a token that has been sent or received by an account on a market"
type MarketActivity @entity {
  "The unique identifier for the market activity"
  id: String!
  "The first time the user interacted with the market"
  creationDate: BigInt!
  "The last time the user interacted with the market"
  latestInteractionDate: BigInt!
  "The market that the activity occurred on"
  market: Market!
  "The account that the activity occurred for"
  account: Account!
  "The total inbound token that has been sent by the user"
  inboundAmountGave: BigInt!
  "The total inbound token that has been received by the user"
  inboundAmountGot: BigInt!
  "The total outbound token that has been sent by the user"
  outboundAmountGave: BigInt!
  "The total outbound token that has been received by the user"
  outboundAmountGot: BigInt!

  "The display value of inboundAmountGave for use in UIs"
  inboundAmountGaveDisplay: BigDecimal!
  "The display value of inboundAmountGot for use in UIs"
  inboundAmountGotDisplay: BigDecimal!
  "The display value of outboundAmountGave for use in UIs"
  outboundAmountGaveDisplay: BigDecimal!
  "The display value of outboundAmountGot for use in UIs"
  outboundAmountGotDisplay: BigDecimal!
}

# TODO: We could merge this with `maker = 0x0` or `taker = 0x0` to get the same as above with less entities
# TODO: We could even use market = 0x0 to replace TokenActivity?
"The total amount of a token that has been sent or received by an account on a market"
type MarketActivityPair @entity {
  "The unique identifier for the market activity"
  id: String!
  "The first time the user interacted with the market"
  creationDate: BigInt!
  "The last time the user interacted with the market"
  latestInteractionDate: BigInt!
  "The market that the activity occurred on"
  market: Market!
  "The maker that the activity occurred for"
  maker: Account!
  "The taker that the activity occurred for"
  taker: Account!
  "The total inbound token that has been sent by the taker"
  inboundAmount: BigInt!
  "The total outbound token that has been sent by the maker"
  outboundAmount: BigInt!

  "The display value of inboundAmount for use in UIs"
  inboundAmountDisplay: BigDecimal!
  "The display value of outboundAmount for use in UIs"
  outboundAmountDisplay: BigDecimal!
}

type TokenActivity @entity {
  "The unique identifier for the token activity"
  id: String!
  "The first time the user interacted with the token"
  creationDate: BigInt!
  "The last time the user interacted with the token"
  latestInteractionDate: BigInt!
  "The token that the activity with"
  token: Token!
  "The account that the activity occurred for"
  account: Account!
  "Total amount of the token that has been sent by the user"
  amountSent: BigInt!
  "Total amount of the token that has been received by the user"
  amountReceived: BigInt!

  "The display value of amountSent for use in UIs"
  amountSentDisplay: BigDecimal!
  "The display value of amountReceived for use in UIs"
  amountReceivedDisplay: BigDecimal!
}

"An ERC20 token that can be traded on Mangrove"
type Token @entity {
  "The unique identifier for the token (same as address in this case)"
  id: Bytes!
  "The address of the token contract"
  address: Bytes!
  "The ERC20 name for the token"
  name: String!
  "The ERC20 symbol for the token"
  symbol: String!
  "The number of decimals to use when displaying the token"
  decimals: BigInt!
}

"A market on mangrove, made up of a token pair and some configuration options"
type Market @entity {
  "The unique identifier for the market"
  id: String!
  "Outbound token of the market"
  outboundToken: Bytes!
  "Inbound token of the market"
  inboundToken: Bytes!
  "Spacing between ticks on the market"
  tickSpacing: BigInt!
  "If the market is able to be used"
  active: Boolean!
  "MISSING COMMENT"
  gasBase: BigInt!
  "The fee charged when trading on the market"
  fee: BigInt!
}

"A pair of Markets that make up a bid/ask pair"
type MarketPair @entity {
  "The unique identifier for the market pair"
  id: String!
  "The time that the pair was created"
  creationDate: BigInt!
  "The time that the pair was updated"
  latestUpdateDate: BigInt!
  "The market that contains the bids"
  bid: Market
  "The market that contains the asks"
  ask: Market
  "The base token of the pair"
  base: Token!
  "The quote token of the pair"
  quote: Token!

  "The mid price of the pair"
  midPrice: BigDecimal
  "Min ask price in tick"
  minAsk: BigInt
  "Max bid price in tick"
  maxBid: BigInt
  "The spread of the pair"
  spread: BigDecimal
  "The total promised base volume of the pair"
  totalVolumePromisedBase: BigInt!
  "The total promised quote volume of the pair"
  totalVolumePromisedQuote: BigInt!
}

"MISSING COMMENT"
type Offer @entity {
  "The unique identifier for the offer"
  id: String!
  "The hash of the latest transaction that the offer was involved in"
  latestTransactionHash: Bytes!
  "MISSING COMMENT"
  latestLogIndex: BigInt!
  "The time that the offer was created"
  creationDate: BigInt!
  "The time that the offer was last updated"
  latestUpdateDate: BigInt!
  "The id of the offer in the Offer list of the market"
  offerId: BigInt!
  "The tick of the offer, used to determine the price"
  tick: BigInt!
  "The amount of the outbound token that the offer gives"
  gives: BigInt!
  "MISSING COMMENT"
  gasPrice: BigInt!
  "MISSING COMMENT"
  gasReq: BigInt!
  "MISSING COMMENT"
  gasBase: BigInt!
  "If the offer is open"
  isOpen: Boolean!
  "If the offer has failed"
  isFailed: Boolean!
  "If the offer has been filled completely"
  isFilled: Boolean!
  "If the offer has been retracted"
  isRetracted: Boolean!
  "The reason the offer failed, if it did"
  failedReason: Bytes
  "The reason the posthook failed, if it did"
  posthookFailReason: Bytes
  "MISSING COMMENT"
  deprovisioned: Boolean!
  "The last penalty that the offer paid"
  latestPenalty: BigInt!
  "The total penalty that the offer has paid across all partial fills"
  totalPenalty: BigInt!
  "The total amount of the inbound token that the offer has got"
  totalGot: BigInt!
  "The total amount of the outbound token that the offer has given"
  totalGave: BigInt!
  "The previous amount of output token that the offer was promising"
  prevGives: BigInt
  "MISSING COMMENT"
  prevTick: BigInt
  "The market that the offer is on"
  market: Market!
  "The wallet or contract that created the offer"
  maker: Account!
  "The wallet that created the offer, traced through Kandels and Limit Orders"
  realMaker: Account
  "MISSING COMMENT"
  owner: Account
  "The limit order that placed the offer, if any"
  limitOrder: LimitOrder
  "The Kandel that placed the order, if any"
  kandel: Kandel
  "The index of the offer in the Kandel offer list"
  kandelIndex: BigInt
  "The amplified offer that the offer belongs to, if any"
  amplifiedOffer: AmplifiedOffer
}

"An event that occurs when an offer is filled on a market"
type OfferFilled @entity {
  "The unique identifier for the OfferFilled event"
  id: String!
  "When the offer was filled"
  creationDate: BigInt
  "The transaction the offer was filled on"
  transactionHash: Bytes!
  "The account that filled the offer"
  taker: Account!
  "MISSING COMMENT"
  account: Account!
  "The market that the offer was on"
  market: Market!
  "The amount of the inbound token that the maker got"
  makerGot: BigInt!
  "The amount of the outbound token that the maker gave"
  makerGave: BigInt!
  "The display value of makerGot for use in UIs"
  makerGotDisplay: BigDecimal!
  "The display value of makerGave for use in UIs"
  makerGaveDisplay: BigDecimal!
  "The offer that was filled"
  offer: Offer
}

"MISSING COMMENT"
type CleanOrder @entity {
  "MISSING COMMENT"
  id: String!
  "MISSING COMMENT"
  transactionHash: Bytes!
  "MISSING COMMENT"
  creationDate: BigInt!

  "MISSING COMMENT"
  taker: Account!
  "MISSING COMMENT"
  offersToBeCleaned: BigInt!
  "MISSING COMMENT"
  orders: [Order!]! @derivedFrom(field: "cleanOrder")

  "MISSING COMMENT"
  market: Market
}

"MISSING COMMENT"
type Order @entity {
  "MISSING COMMENT"
  id: String!
  "MISSING COMMENT"
  transactionHash: Bytes!
  "MISSING COMMENT"
  creationDate: BigInt!

  "MISSING COMMENT"
  fillVolume: BigInt!
  "MISSING COMMENT"
  fillWants: Boolean!
  "MISSING COMMENT"
  maxTick: BigInt!
  "MISSING COMMENT"
  taker: Account!
  "MISSING COMMENT"
  takerGot: BigInt!
  "MISSING COMMENT"
  takerGave: BigInt!
  "MISSING COMMENT"
  penalty: BigInt!
  "MISSING COMMENT"
  feePaid: BigInt!

  "THe market that the order is on"
  market: Market
  "The limit order that the order is tied to, if any"
  limitOrder: LimitOrder
  "MISSING COMMENT"
  cleanOrder: CleanOrder
}

"An offer placed by an amplified offer"
type AmplifiedOffer @entity {
  "The unique identifier for the amplified offer"
  id: String!

  "The logic to use to receive incoming tokens"
  inboundRoute: Bytes
  "The logic to use to source outgoing tokens"
  outboundRoute: Bytes

  "The bundle of offers that the offer belongs to"
  bundle: AmplifiedOfferBundle!
  "The owner of the amplified offer"
  owner: Account
  "The underlying offer that is tied to this amplified offer"
  offer: Offer!
}

"A bundle of offers that are tied together by an amplified offer"
type AmplifiedOfferBundle @entity {
  "The unique identifier for the bundle"
  id: String!
  "The time at which the bundle was created"
  creationDate: BigInt!
  "The id of the bundle inside of the amplifier"
  bundleId: BigInt!
  "The time at which the offers expire, if any"
  expiryDate: BigInt!

  "The offers that are tied to the bundle"
  offers: [AmplifiedOffer!]!
  "The owner of the bundle"
  owner: Account
}

"A limit order that is placed on a market"
type LimitOrder @entity {
  "The unique identifier for the limit order"
  id: String!
  "The time at which the limit order was created"
  creationDate: BigInt!
  "The last time that the limit order was updated"
  latestUpdateDate: BigInt!
  "The time at which the offer expires, if any"
  expiryDate: BigInt
  "MISSING COMMENT"
  maxVolume: BigInt
  "MISSING COMMENT"
  orderType: Int!
  "The tick of the limit order, used to determine the price"
  tick: BigInt!
  "MISSING COMMENT"
  fillVolume: BigInt!
  "MISSING COMMENT"
  fillWants: Boolean!

  "MISSING COMMENT"
  realTaker: Account!

  "The logic to use to receive incoming tokens"
  inboundRoute: Bytes!
  "The logic to use to source outgoing tokens"
  outboundRoute: Bytes!

  "The underlying offer that is tied to this limit order"
  offer: Offer
  "The order that is tied to the limit order"
  order: Order

  "If the limit order is open"
  isOpen: Boolean
}

"An event that occurs when a token is deposited or withdrawn from a Kandel"
type KandelDepositWithdraw @entity {
  "The unique identifier for the deposit or withdraw event"
  id: String!
  "The transaction that the event occurred in"
  transactionHash: Bytes!
  "The time that the event occurred"
  date: BigInt!
  "The token that was moved"
  token: Bytes!
  "The amount of the token that was moved"
  amount: BigInt!
  "If the event was a deposit, otherwise it was a withdraw"
  isDeposit: Boolean!

  "The Kandel that the event occurred in"
  kandel: Kandel!
}

"The type of Kandel contract"
enum KandelType {
  "A Kandel contract"
  Kandel
  "A SmartKandel contract that uses Liquidity Sourcing, not deposit/withdrawing"
  SmartKandel
}

"A Kandel contract with some configuration options and parameters"
type Kandel @entity {
  "The unique identifier for the Kandel"
  id: Bytes!
  "The transaction that created the Kandel"
  transactionHash: Bytes!
  "When the Kandel was created"
  creationDate: BigInt!

  "The address of the KandelSeeder contract that seeded the Kandel"
  seeder: Bytes!
  "The address of the Kandel contract"
  address: Bytes!

  "The base token of the Kandel"
  base: Bytes!
  "The quote token of the Kandel"
  quote: Bytes!
  "The hash of the OL key for the market that is inbound base, outbound quote"
  baseQuoteOlKeyHash: Bytes!
  "The hash of the OL key for the market that is inbound quote, outbound base"
  quoteBaseOlKeyHash: Bytes!
  "The account that deployed the Kandel"
  deployer: Account!
  "The account that is allowed to manage the Kandel"
  admin: Account!

  "The logic used to receive incoming tokens"
  inboundRoute: Bytes
  "The logic used to source outgoing tokens"
  outboundRoute: Bytes

  "The type of the Kandel contract"
  type: KandelType!

  # Only for kandel AAVE
  "MISSING COMMENT"
  reserveId: Bytes
  "MISSING COMMENT"
  router: Bytes

  "The amount of the base token that has been deposited into the Kandel"
  depositedBase: BigInt!
  "The amount of the quote token that has been deposited into the Kandel"
  depositedQuote: BigInt!

  "The total amount of the base token that has been published"
  totalPublishedBase: BigInt!
  "The total amount of the quote token that has been published"
  totalPublishedQuote: BigInt!

  # Parameters
  "MISSING COMMENT"
  gasPrice: BigInt
  "MISSING COMMENT"
  gasReq: BigInt
  "MISSING COMMENT"
  stepSize: BigInt
  "MISSING COMMENT"
  baseQuoteTickOffset: BigInt
  "MISSING COMMENT"
  length: BigInt

  "MISSING COMMENT"
  offerIndexes: [String!]!

  "The underlying offers that are managed by this Kandel"
  offers: [Offer!]! @derivedFrom(field: "kandel")
  "The deposit or withdraw events that have occurred for this Kandel"
  depositWithdraws: [KandelDepositWithdraw!]! @derivedFrom(field: "kandel")
  "The collection of historical parameters that the Kandel has been configured with"
  parameters: [KandelParameters!]! @derivedFrom(field: "kandel")
  "MISSING COMMENT"
  populateRetracts: [KandelPopulateRetract!]! @derivedFrom(field: "kandel")
}

"MISSING COMMENT"
type KandelPopulateRetract @entity {
  "MISSING COMMENT"
  id: String!
  "MISSING COMMENT"
  transactionHash: Bytes!
  "MISSING COMMENT"
  creationDate: BigInt!
  "MISSING COMMENT"
  startLogIndex: BigInt!

  "If the event is a retract, otherwise it is a populate"
  isRetract: Boolean!
  "MISSING COMMENT"
  offerGives: [String!]!

  "The Kandel that the event is tied to"
  kandel: Kandel!
}

"The collection of parameters that a Kandel is configured with, used for historical purposes"
type KandelParameters @entity {
  "The unique identifier for the Kandel parameters"
  id: String!
  "The transaction that the parameters were set in"
  transactionHash: Bytes!
  "The time that the parameters were set"
  creationDate: BigInt!

  "MISSING COMMENT"
  gasPrice: BigInt
  "MISSING COMMENT"
  gasReq: BigInt
  "MISSING COMMENT"
  baseQuoteTickOffset: BigInt
  "MISSING COMMENT"
  stepSize: BigInt
  "MISSING COMMENT"
  length: BigInt

  "The Kandel that the parameters are for"
  kandel: Kandel!
}

"Internal - Used for storing items that span multiple events"
type Stack @entity {
  "The id of the stack"
  id: String!
  "The items currently in the stack, encoded as a single string"
  ids: String!
}
